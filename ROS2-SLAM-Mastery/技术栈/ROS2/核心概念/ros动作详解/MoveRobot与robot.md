

# `MoveRobot`接口 与 `robot`类

在 `Robot` 类中并没有直接使用接口 `MoveRobot::Feedback` 或 `MoveRobot::Result` 结构体作为**==成员变量==**，而是将**位置**和**状态数据**（例如 `current_pose_` 和 `status_`）作为 `Robot` 类的**私有成员变量**来管理。`Robot` 类在运行过程中更新这些私有数据成员，然后在其他地方（如 `execute_move` 函数）中，通过 `Robot` 的方法调用（如 `get_current_pose()` 和 `get_status()`）来访问这些数据并填充到接**口结构体**,比如说在程序中定义的`result`和`feedback`中。

## 特点 

1. **接口与实现分离**：
   - `MoveRobot::Feedback` 和 `MoveRobot::Result` 结构体主要用于描述和传递动作相关的数据类型，而不是用于存储机器人的状态数据。这种方式遵循了==接口与实现分离的原则==。
   - `Robot` 类负责管理数据（如 `current_pose_` 和 `status_`），而不直接依赖于接口的数据结构。这种设计使得 `Robot` 类更加独立，只提供接口数据所需的内容，而不完全受限于接口的定义。

2. **数据管理的清晰职责分配**：
   - **接口并不提供数据的储存，而是提供一种数据类型的描述**。`MoveRobot` 接口的结构体只是用来描述动作反馈的类型，而 `Robot` 类中定义的私有成员（如 `current_pose_`）则负责存储实际运行时的状态。
   - 这种设计可以避免 `Robot` 类对接口的**==过度依赖==**。比如，接口的定义可能会随需求改变，但 `Robot` 类只需要维护自己核心的状态信息，减少了耦合。

3. **分层管理数据副本**：
   - `Robot` 类通过自己的成员变量（如 `current_pose_`）和方法（如 `get_current_pose()`）管理状态信息，并**提供**了将数据拷贝到接口结构体的途径。这种设计在逻辑上分离了数据的生成、管理和发布，使得每个部分的职责更加清晰。

### 一些疑问

> 为什么在 `robot.h` 中没有直接使用 `MoveRobot::Result::pose`，而是使用 `float` 类型的 `current_pose_`？

确实，`MoveRobot::Result` 中的 `pose` 和 `Robot` 类中的 `current_pose_` 都表示位置信息。可以考虑直接使用接口类型中的 `pose` 来统一类型，但这样设计会带来一些限制：

- **接口的独立性和灵活性**：

  - 如果直接使用 `MoveRobot::Result` 的 `pose` 作为成员变量，就会让 `Robot` 类对接口产生**==较强的依赖性==**。这可能会在接口变动时给 `Robot` 类带来不必要的耦合。

  - 使用 `float` 这种独立的基本类型意味着 `Robot` 类可以根据需要定义、存储和处理数据，而不依赖接口的具体实现。

### 总结

- **接口与实现分离**：`MoveRobot` 的 `Feedback` 和 `Result` 结构体只是描述动作数据的接口，而 `Robot` 类负责数据的实际存储和管理。这种设计避免了 `Robot` 对接口的过多依赖，保持了灵活性。
- **数据管理与反馈的独立性**：`Robot` 类通过自己的 `current_pose_` 和 `status_` 存储机器人状态，提供独立的接口方法来访问这些数据，而不是直接使用接口结构体字段。
- **简化耦合**：直接使用 `float` 和 `int` 这样的基本类型可以减少对接口的依赖，使 `Robot` 类更通用，更易维护。
